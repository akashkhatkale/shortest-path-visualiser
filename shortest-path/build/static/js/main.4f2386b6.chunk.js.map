{"version":3,"sources":["components/Node.js","algorithms/dijkstras.js","App.js","index.js"],"names":["Node","this","props","isFinish","isStart","row","col","extraClassName","isWall","id","className","Component","dijkstras","grid","startNode","finishNode","distance","unvisitedNodes","nodes","node","push","getAllNodes","orderedVisitedNodes","length","sort","nodeA","nodeB","closest","shift","Infinity","isVisited","updateNeighboursDistance","neighbours","n","unvisitedNeighbours","filter","neighbour","unvisited","previousNode","App","state","startCoordinates","endCoordinates","isWallClicked","walls","onNodeClicked","bind","visualisDijkstra","onWallClicked","console","log","generateGrid","setState","end","start","getStartNode","endNode","getEndNode","visitedNodes","orderedNodes","nodesInShortestPath","currentNode","unshift","orderedShortestPath","i","setTimeout","document","getElementById","onClick","demo","style","color","marginTop","map","nodeRow","rowIndex","colIndex","Array","_","r","c","newNode","createNodeWall","createNode","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.4f2386b6.chunk.js","sourcesContent":["\nimport React, { Component } from 'react'\nimport './Node.scss'\n\nexport default class Node extends Component {\n    render() {\n        const { isFinish, isStart, row, col, isWall } = this.props\n        const extraClassName = isWall ? 'wall' : isFinish ? 'finish' : isStart ? 'start' : 'default'\n        return (\n            <div id={`node-${row}-${col}`} className={`node-${extraClassName}`}>\n            </div>\n        )\n    }\n}","\n\nexport function dijkstras(grid, startNode, finishNode) {\n    startNode.distance = 0\n    const unvisitedNodes = getAllNodes(grid);\n    const orderedVisitedNodes = [];\n    while (!!unvisitedNodes.length) {\n        unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n        const closest = unvisitedNodes.shift()\n        if (closest.distance == Infinity) return orderedVisitedNodes; // no solution \n        if (closest.isWall) continue;\n        if (closest == finishNode) return orderedVisitedNodes // reached finish node\n        closest.isVisited = true\n        orderedVisitedNodes.push(closest)\n\n        // update distance of neighbours\n        updateNeighboursDistance(closest, grid)\n    }\n\n    return orderedVisitedNodes\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (let row of grid) {\n        for (let node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\n\n\n\nfunction updateNeighboursDistance(node, grid) {\n    const neighbours = [];\n    const { col, row } = node;\n    // the checks are done to make sure the array is not out of bounds\n    if (col < grid[0].length - 1) {\n        // right neighbour\n        var n = grid[row][col + 1]\n\n        neighbours.push(n)\n    }\n    if (row < grid.length - 1) {\n        // bottom neighbour\n        var n = grid[row + 1][col]\n\n        neighbours.push(n)\n    }\n    if (row > 0) {\n        // upper neighbour\n        var n = grid[row - 1][col]\n\n        neighbours.push(n)\n    }\n    if (col > 0) {\n        // left neighbour\n        var n = grid[row][col - 1]\n\n        neighbours.push(n)\n    }\n\n    const unvisitedNeighbours = neighbours.filter(neighbour => !neighbour.isVisited)\n    for (const unvisited of unvisitedNeighbours) {\n        unvisited.distance = node.distance + 1;\n        unvisited.previousNode = node;\n    }\n}\n\n\nexport function orderedShortestPath(finishNode) {\n    const nodesInShortestPath = [];\n    let currentNode = finishNode; //setup initial node as the final node\n    while (currentNode !== null) { //while current node isn't start node\n        nodesInShortestPath.unshift(currentNode); //keep adding current node to front of array\n        currentNode = currentNode.previousNode; //update currentNode\n    }\n    return nodesInShortestPath;\n}","import './App.scss';\nimport React, { Component, useState } from 'react'\nimport Node from './components/Node'\nimport './App.scss'\nimport { dijkstras, orderedShortestPath } from './algorithms/dijkstras';\n\n\nclass App extends Component {\n\n  constructor(props) {\n    super(props)\n    this.state = {\n      grid: [],\n      startCoordinates: [5, 5],\n      endCoordinates: [8, 30],\n      isWallClicked: false\n    }\n\n    this.walls = {}\n    this.isWall = false\n    this.onNodeClicked = this.onNodeClicked.bind(this)\n    this.visualisDijkstra = this.visualisDijkstra.bind(this)\n    this.onWallClicked = this.onWallClicked.bind(this)\n  }\n\n  onNodeClicked(row, col) {\n    const { startCoordinates, endCoordinates } = this.state;\n    console.log(\"gen grid\")\n    if (this.isWall) {\n      // set the wallss\n      console.log(\"setting the walls\")\n      this.walls[`${row},${col}`] = \"wall\"\n      console.log(\"walls \" + this.walls)\n      const grid = generateGrid(startCoordinates, endCoordinates, this.walls);\n      this.setState({\n        grid\n      })\n      return\n    } else {\n      if (startCoordinates[0] == -1 && startCoordinates[1] == -1) {\n        // set the start node\n        const start = [row, col]\n        const grid = generateGrid(start, endCoordinates, this.walls)\n        this.setState({\n          startCoordinates: start,\n          grid: grid\n        })\n        return\n      } else {\n\n        if (row == startCoordinates[0] && col == startCoordinates[1]) {\n          // remove the start node\n          const start = [-1, -1]\n          const grid = generateGrid(start, endCoordinates, this.walls)\n          this.setState({\n            startCoordinates: start,\n            grid: grid\n          })\n          return\n        } else if (row == endCoordinates[0] && col == endCoordinates[1]) {\n          // remove the end node\n          const end = [-1, -1]\n          const grid = generateGrid(startCoordinates, end, this.walls)\n          this.setState({\n            endCoordinates: end,\n            grid: grid\n          })\n          return\n        } else {\n          // set the end node\n          const end = [row, col]\n          const grid = generateGrid(startCoordinates, end, this.walls)\n          this.setState({\n            endCoordinates: end,\n            grid: grid\n          })\n          return\n        }\n\n      }\n    }\n\n  }\n\n\n  visualisDijkstra() {\n    const { grid, startCoordinates, endCoordinates } = this.state;\n    const startNode = getStartNode(startCoordinates[0], startCoordinates[1], grid);\n    const endNode = getEndNode(endCoordinates[0], endCoordinates[1], grid);\n    const visitedNodes = dijkstras(grid, startNode, endNode)\n    const orderedNodes = orderedShortestPath(endNode)\n\n\n    for (let i = 0; i < visitedNodes.length; i++) {\n      const node = visitedNodes[i];\n\n      setTimeout(() => {\n        if (!node.isStart) document.getElementById(`node-${node.row}-${node.col}`).className = 'node-visited'\n        if (i == visitedNodes.length - 1) {\n          for (let i = 1; i < orderedNodes.length - 1; i++) {\n            setTimeout(() => {\n              const node = orderedNodes[i];\n              document.getElementById(`node-${node.row}-${node.col}`).className = 'node-path';\n            }, 50 * i);\n          }\n        }\n      }, 10 * i);\n    }\n  }\n\n\n  componentDidMount() {\n    const grid = generateGrid(this.state.startCoordinates, this.state.endCoordinates, this.walls)\n    this.setState({ grid })\n  }\n\n\n  onWallClicked() {\n    const { isWallClicked } = this.state;\n    this.isWall = !this.isWall\n    this.setState({ isWallClicked: !isWallClicked })\n  }\n\n\n  // render \n  render() {\n    const { grid, isWallClicked } = this.state;\n    return (\n      <div className=\"App\">\n        <div className=\"upper\" onClick={this.demo}>\n          <h1 style={{ color: 'white' }}><span style={{ color: '#00a6e7' }}>ShortestPath</span>Visualiser</h1>\n        </div>\n\n        <div style={{ marginTop: '10px' }}>\n          <button className=\"sortButton\" onClick={this.visualisDijkstra}>Visualise (Dijkstra's)</button>\n          <button className={isWallClicked ? 'sortButtonClicked' : 'sortButton'} onClick={this.onWallClicked}>Add Wall</button>\n        </div>\n\n\n\n        <div className=\"grid\">\n          {\n            grid.map((nodeRow, rowIndex) => {\n              return (<div className=\"row\" key={rowIndex}>\n                {\n                  nodeRow.map((node, colIndex) => {\n                    const { isStart, isFinish, row, col, isWall } = node;\n                    return (<div onClick={() => this.onNodeClicked(row, col)} className=\"column\" key={colIndex}>\n                      <Node\n                        key={colIndex}\n                        isStart={isStart}\n                        isFinish={isFinish}\n                        row={row}\n                        col={col}\n                        isWall={isWall}\n                      />\n                    </div>)\n                  })\n                }\n              </div>)\n            })\n          }\n        </div>\n\n\n      </div>\n    );\n  }\n\n\n}\n\nexport default App;\n\n\n\nconst generateGrid = (start, end, walls) => {\n  const grid = [];\n  [...Array(20)].map((_, r) => {\n    const row = [];\n    [...Array(40)].map((_, c) => {\n      if (walls[`${r},${c}`] != null) {\n        console.log(\"includes\")\n        let newNode = createNodeWall(r, c, start, end);\n        row.push(newNode)\n      } else {\n        let newNode = createNode(r, c, start, end);\n        row.push(newNode)\n      }\n    })\n    grid.push(row)\n  })\n\n  return grid\n}\n\n\n\n// create a node\nconst createNode = (row, col, start, end) => {\n  const Node = {\n    col: col,\n    row: row,\n    distance: Infinity,\n    isStart: row === start[0] && col === start[1],\n    isFinish: row === end[0] && col === end[1],\n    isWall: false,\n    isVisited: false,\n    previousNode: null,\n  }\n  return Node\n}\n\n// create a node wall \nconst createNodeWall = (row, col, start, end) => {\n  const Node = {\n    col: col,\n    row: row,\n    distance: Infinity,\n    isStart: row === start[0] && col === start[1],\n    isFinish: row === end[0] && col === end[1],\n    isWall: true,\n    isVisited: false,\n    previousNode: null,\n  }\n  return Node\n}\n\n// get start node and end node\nconst getStartNode = (row, col, grid) => {\n  const Node = grid[row][col]\n  return Node\n}\nconst getEndNode = (row, col, grid) => {\n  const Node = grid[row][col]\n  return Node\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}